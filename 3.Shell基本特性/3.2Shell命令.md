## 3.2 Shell命令（Shell Commands）

一个简单命令，如“echo a b c”，是由其命令本身和若干参数（arguments）组成的，并由空格将命令和参数分隔的。

更复杂的shell命令是由若干简单命令以多种方式排列组合起来的：如一个命令的输出作为另一命令的输入的管道形式，或在一个循环和条件结构中，再或在其它形式的命令组合中。

### 3.2.1 保留字（Reserved Words）

保留字是shell中具有特殊意义的单词。它们用在shell复合命令的开头或结尾。

下列单词如果未被引起来并且是命令的第一个单词，则被认为是保留字：

`if then elif else fi time`

`for in until while do done`

`case esac coproc select function`

`{ } [[ ]] !`

也有一些例外：

`in`如果出现在case或select命令的第三个单词位置时，才会被认为是保留字。

`in`和`do`出现在for命令的第三个单词位置时，才会被认为是保留字。

### 3.2.2 简单命令（Simple Commands）

简单命令是出现最多的一种命令。它仅仅是由一序列被空白分开的单词组成的，并由一个shell控制操作符作（参见第2章《定义》）为结束的命令。简单命令中第一个单词一般是用于执行的命令名，其后所有的单词作为这个命令的参数（arguments）。

简单命令的返回状态（参见章节3.7.5《退出状态》）即它的退出状态，是由POSIX 1003.1定义的waitpid函数提供的，或由命令的终结信号“n”+128得到的。

### 3.2.3 管道（Pipelines）

管道是由控制操作符“|”或“|&”将多个命令连接起来的命令序列。其格式是：

<span style="background-color:lightgray">[time [-p]] [!] <i>command1</i> [ | or |& <i>command2</i> ] ...</span>


如果使用“|&”，command1的标准报错附加其标准输出会通过管道连接到command2的标准输入中去；这是“2>&1”的简写方式。这种将标准报错合并到标准输出的隐式重定向会在这个命令的任意重定向之后执行。

保留字time会打印该管道完成后的时间统计信息。当前的统计信息是由这个命令执行时的使用时间（时钟时间）和用户及系统时间组成。“-p”选项将输出格式改为POSIX格式。当shell运行于POSIX模式（参见章节6.11《Bash POSIX模式》）时，如果time后面跟着标记“-”时是不会认为time是保留字。变量“TIMEFORMAT”用于指定时间统计信息的显示格式，可参见5.2章节《Bash变量》关于可用格式的说明。time作为保留字可以用于测量shell内建命令、函数及管道的运行时间。外部命令“time”不能很容易地实现命令运行时间的测量。

在POSIX模式时，time可能直接跟随一个换行。在这种情况下，shell会显示shell和子shell的总的用户和系统消耗时间。变量“TIMEFORMAT”也可用于指定时间信息格式。

如果管道未运行于异步处理（参见3.2.4《列表》）中，shell会等等管道中所有命令执行完成。

在管道中执行的每一个命令都执行于其拥有的子shell中，即使用分开的处理进程（参见3.7.3《命令执行环境》）。如果使用内建命令shopt开启了“lastpipe”选项，则管道中最后一个元素则运行于shell进程中，而不是子shell中。

管道的退出状态即管道中最后一条命令的退出状态，除非开启了“pipefail”选项（参见4.3.1《设置内建命令》）。如果开启了“pipefail”，管道的返回状态是最后（即最右边）一条命令的非零退出状态，或表示所有命令成功退出的零状态。如果保留字“!”出现在管道之前，退出状态则取为上面所描述的退出状态的逻辑反。shell会等待管道中所有命令完成后才会返回退出状态值。

### 3.2.4 命令列表（Lists of Commands）

列表是使用操作符“;”、“&”、“&&”或“||”将一个或多个管道连接起来的命令序列。可选择使用“;”、“&”或换行（newline）作为终结符。

在这些操作符中，“&&”和“||”具有相同的优先级，之后是“;”和“&”。

在列表序列中出现的一个或多个换行可以用于分隔命令，其作用等同于分号。

如果命令结束于控制符“&”时，shell则在子shell中执行异步处理。这也被称作在后台（background）执行命令，并且这些命令参考为异步命令。shell不会等待这些命令完成，并且返回状态为零（即真值）。当作业控制没有激活（参见第7章《作业控制》），在缺少显式重定向的用于异步命令的标准输入，会重定向从“/dev/null”进行输入。

使用分号“;”进行分隔的命令是按顺序执行的；shell轮流等待每一个命令执行完成。返回状态是最后一条命令的退出状态。

“AND”和“OR”列表是分别使用控制操作符“&&”和“||”分隔的一个或多个管道命令所组成的。“AND”和“OR”列表执行时遵循左结合性。

“AND”列表格式是`command1 && command2`。只有当command1执行后返回状态为零（即成功）后，才能执行command2。

“OR”列表格式是`command1 || command2`。只有当command1返回状态为非零时，才会执行command1。

“AND”和“OR”列表的返回状态是其最后一条命令的返回状态。

### 3.2.5 复合命令（Compound Commands）

复合命令是shell编程语言的结构体。每一个结构体是开始于一个保留字或控制操作符，并且结束于一个相应的保留字或操作符。任意关联于复合命令的重定向都应用到复合命令中的每一个命令，除非显式地复写它。

在大多数情况下，在复合命令中的命令列表都是使用一个或多个换行来与其它命令进行分隔的，并且使用换行代替末尾的分号。

Bash提供循环结构体、条件判断命令和命令成组机制，并且将其作为一个单元执行。

#### 3.2.5.1 循环结构体（Looping Constructs）

Bash支持以下循环结构体。

> 注意，无论下面命令语法中在哪里出现的分号“;”，其都可以使用换行进行替代。

**until**

语法：

`until test-commands; do consequent-commands; done`

必须在测试命令“test-commands”的退出状态不为零时，执行命令体“consequent-commands”里的命令。这个结构体的返回状态是其命令体里最后一条命令的退出状态，或如果什么都没执行则是零。

**while**

语法：

`while test-commands; do consequent-commands; done`

当测试命令“test-commands”退出状态为零时，才执行命令体“consequent-commands”里的命令。这个结构体的返回状态是其命令体里最后一条命令的退出状态，或如果什么都没执行则是零。

**for**

语法：

`for name [ [ in [words ...] ] ; ] do commands; done`

使用“name”所代表的变量轮流绑定由“words”扩展生成的多个元素，并为每一个当前元素执行一遍“commands”执行体里的命令。如果“in words”没有给出，for命令则将位置参数作为元素列表。就像使用了“in "$@"”一样。（参见章节3.4.2《特殊参数》）。

返回状态是其最后一条命令的退出状态。如果“words”扩展没有生成任何元素，则不会执行任何执行体里的命令，并且返回状态为零。

还有另外一种语法格式：

`for (( expr1; expr2; expr3 )) ; do commands ; done`

首先，算术表达式“expr1”按照算术规则（参见6.5《Shell算术运算》）进行运算。接着算术表达式“expr2”进行重复性运算，直到其运算得到零。每一次“expr2”运算得到一个非零值时，都要执行命令体“commands”里的命令对“expr3”进行一次运算。如果省略了任意一个表达式，则其运算值就被视为1。返回值是命令体最后一条命令的退出状态，或返回假值如果任意一个表达式是无效的。

内建命令“break”和“continue”（参见4.1《Bourne Shell内建命令》）可以用于控制循环的执行。

#### 3.2.5.2 判断结构体（Conditional Constructs）

**if**

语法：

```
if test-commands; then
    consquent-commands;
[elif more-test-commands; then
    more-consequents;]
[else alternate-consequents;]
fi
```

如果执行测试命令“test-commands”后返回状态为零，则执行命令体“consequent-commands”。如果测试命令“test-commands”执行返回非零状态，则轮流执行存在的elif语句体。如果该语句的测试命令“more-test-commands”返回状态零，则执行相应的“more-consequents”命令体并完成整个判断命令。如果“else alternate-consequents”出现，并且所有if和elif语句有一个非零的退出状态，则执行“alternate-consequents”命令体。该结构体的返回状态是最后一条命令的退出状态，或如果没有条件测试成功则返回零。

**case**

语法：

```
case word in
    [ [(] pattern [| pattern]...) command-list ;;]...
esac
```

case语句将选择性地执行第一次单词“word”匹配到的样式“pattern”那行相关的命令列表“command-list”里的命令。匹配的执行规则请参见3.5.8.1《样式匹配》。如果shell选项“nocasematch”开启（详见4.3.2《内建命令shopt》命令shopt描述），将使用大小写不敏感的匹配。“|”用于分隔多个样式，并且“)”代表样式列表结束。一个样式列表和相关联的命令列表“command-list”被称作一个子句（clause）。

每一个子句必须使用“;;”、“;&”或“;;&”表示结束。在进行匹配之前，word可以进行波浪号扩展、参数扩展、命令替换、算术扩展和引用移除（以上扩展请参见3.5.3《Shell参数扩展》）运算。每一个样式也可进行
波浪号扩展、参数扩展、命令替换和算术扩展。

可以使用任意多个case子句，每一个子句结束符都可以是“;;”、“;&”或“;;&”。第一个匹配到的样式决定了执行哪个相关的命令列表。有一种通用习惯，使用星号“*”作为默认case语句匹配样式，也就是该样式总是会被匹配到。

下面的例子是使用case语句对感兴趣的动物进行选择的脚本：

```
echo -n "Enter the name of an animal: "
read ANIMAL
echo -n "The $ANIMAL has "
case $ANIMAL in
  horse | dog | cat) echo -n "four";;
  man | kangaroo ) echo -n "two";;
  *) echo -n "an unknown number of";;
esac
echo " legs."
```
如果使用了“;;”操作符，该子句执行完后，将不会再进行后继的样式匹配。如果使用“;&”替换了“;;”，则该子句执行完成后会继续直接执行下一个子句中的命令（如果存在的话）而不需要进行后继的匹配。如果使用“;;&”替换了“;;”，则会对下一个子句（如果存在的话）进行匹配测试，如果匹配成功则执行其相应的命令，如果不成功则继续对后面的子句进行匹配测试。

如果没有任何匹配成功，则返回状态零。否则，返回执行命令列表的退出状态。

**select**

select结构体可以很容易地生成菜单。它的语法格式和for命令差不多。

语法：

`select name [ in words ...]; do commands; done`

在保留字“in”后面的“words”列表会先进行扩展，生成一个条目列表。扩展后的“words”集合会打印输出到标准报错流中，并且其各项前面会加入数字序号。如果在语法中省略了“in words”，则就像指定了“in "$@"”一样，会将位置参数打印出来。之后会以变量PS3的值作为提示符进行从标准输入的读操作。如果输入行输入了显示列表中的一个条目所对应的数字，则相应的“word”就被赋值给了变量“name”。如果输入行是空的，这个条目列表和提示符会重新显示。如果读到了EOF，则select命令完成。读取的任何其它值将引起“name”设置为空。这个输入行读取的内容会被保存到变量“REPLY”中。

在每一次选择之后都会执行命令集“commands”，直到执行break命令才会完成select命令。

下面的例子是让用户从当前目录选择一个文件名，并打印该文件名和选择序号。

```bash
select fname in *;
do
  echo you picked $fname \($REPLY\)
  break;
done
```

**((...))**

`(( expression ))`
算术表达式会依照其运算规则（参见6.5《Shell算术运算》）进行运算。如果表达式的值不为零，则返回状态为零；其它值返回状态为一。该形式等同于“let "expression"”。可参见4.2《Bash内建命令》关于let的完整描述。

**[[ ... ]]**

`[[ expression ]]`
条件判断表达式返回状态为零或一，完全取决于其运算结果。该表达式的详细描述可参考6.4《Bash条件表达式》。不会将“[[”与“]]”之间的单词进行单词分割（word splitting）和文件名扩展；但会执行波浪号扩展、参数和变量扩展、算术扩展、命令替换、进程替换、和引用移除。条件操作符，如“-f”，只有在未被用引号引起来时才能被认为是操作符。当“<”和“>”号在“[[”后使用时，才作为当前语言区域的按字典排序操作符使用。

当使用“==”和“!=”操作符时，在操作符右边的字符串被认为是一个样式，并且依照3.5.8.1《样式匹配》中的规则进行匹配，就像开启了“extglob”选项一样。“=”与“==”操作符是一样的。如果shell选项“nocasematch”开启（详见4.3.2《内建命令shopt》），匹配时则大小写不敏感。当字符串与样式匹配（使用“==”时）或不匹配（使用“!=”时）时返回状态为零，反之返回状态为一。在样式中任意部分如果被引号括起来，则代表这部分必须精确匹配。

还有一个二元操作符“=~”也是可用的，其与“==”和“!=”具有相同的优先级。当使用它时，操作符右边的字符串被认为是POSIX扩展的正则表达式并依据其规则进行匹配（可在regex(3)中查盾POSIX的regcomp和regexec接口的详细描述）。如果字符串匹配了样式则返回值为0，否则为1。如果正则表达式有语法错误，则判断表达式返回值是2。如果shell选项“nocasematch”开启（详见4.3.2《内建命令shopt》），匹配时则大小写不敏感。在样式中任意部分如果被引号括起来，则代表这部分必须精确匹配。在正则表达式中使用带有中括号表达式时要特别小心，毕竟在中括号之间的正常引用字符会丢失其意义。如果样式存储于一个shell变量中，将变量表达式引起来会将整个样式按字符串进行强制匹配。

如果样式匹配到字符串的任意部分，就算其匹配成功。在样式中使用正则表达式的锚点操作符“^”和“$”会进行整个字符串的强制匹配。数组变量“BASH_REMATCH”记录了匹配到样式的字符串部分。索引为0的“BASH_REMATCH”元素记录的是匹配了整个正则 表达式的字符串部分。在正则表达式中由小括号引起来的子表达式的匹配字符串存储于变量“BASH_REMATCH”的后面索引中。“BASH_REMATCH”的索引n位，存储着第n次小括号子表达式匹配的字符串部分。

例如，下面的表达式将存储于变量“line”中的字符串进行匹配。匹配的是一串包含“space”字符类中的任意个字符，包括零个，和一个或零个字母“a”和一个字母“b”。

`[[ $line =~ [[:space:]]*(a)?b ]]`

这表示像“aab”和“aaaaaab”的字符串都会被匹配，如同一行中字母“b”出现在任何位置一样。

将正则表达式存储于变量中是一种常用手段。其可以避免特殊字母引用的问题。有时很难在关注Shell引用移除（Quote Removal）的同时，不使用引号而正确地指定正则表达式，或跟踪正则表达式引用。使用shell变量来存储样式就减少了这种问题的发生。例如，下面的语句等同于上面的语句：

`pattern='[[:space:]]*(a)?b'`

`[[ $line =~ $pattern ]]`

如果你想要匹配一个正则表达式语法中的一个特殊字符时，必须使用引号将其特殊含义去除。这就是说在样式“xxx.txt”中的点符号“.”在正则表达式中代表可匹配任意一个字符，但在被双引号引起来的样式“"xxx.txt"”中的点符号只匹配其本身。Shell程序员要特别注意反斜线的使用，其可以在shell和正则表达式中用于移除后面字符的特殊意义。下面两组命令是不相等的：

```bash
pattern='\.'

[[ . =~ $pattern ]]
[[ . =~ \. ]]

[[ . =~ "$pattern" ]]
[[ . =~ '\.' ]]
```

第一组匹配是成功的，但第二组不会。因为在第二组的反斜线作为样式的一部分参加匹配。在第一组样例中，反斜线移除了点符号“.”的特殊命令，所以字母“.”匹配到了。如果在第一组中的字符串不是字母“.”，比如是字母“a”，样式中不会匹配到的。因为在样式中的“.”失去了其特殊含义，即用于匹配任意字符。

表达式可以使用下列操作符进行混合使用，优先级按列出的顺序做降序：

**( expresion )**   
返回表达式的值。这可用于覆盖正常的操作符优先级。

**! expression**    
对表达式的状态求反。

**expression1 && expression2**  
如果两个表达式都为真则返回真。

**expression1 || expression2**  
如果两个表达式中有一个为真，则返回真。

在使用“&&”和“||”时，如果表达式1的值可以充分确定整个条件表达式的返回值时，其不会对表达式2再进行运算。

#### 3.2.5.3 成组命令（Grouping Commands）

Bash提供两种方法将要执行的命令列表组成一个单元。当命令被组成到一起，重定向可应用于整个命令列表。例如，可将所有命令列表中的命令输出重定向到一个流中。

**( list )**    
将命令列表置于小括号中，可引起子shell环境（参考3.7.3《命令执行环境》）的创建情况发生。并且列表中的每一个命令都执行于之个子shell中。一旦命令执行于子shell中，在子shell完成退出之后，其间进行的变量赋值将不会被保留下来。

**{ list; }** 
将命令列表置于大括号中，这些命令将在当前shell上下文中执行，而不会创建子shell。命令列表后面的分号（或换行）是必须出现的。

除了在这两种结构体中有创建子shell的不同，还有一个由于历史原因的微妙的不同。大括号属于保留字，所以其必须和命令列表用空白或其它shell元字符分开。小括号是操作符，是被shell认可的分隔标记，其可以不使用空格与命令列表隔开。

这两种结构体的退出状态即是命令列表的退出状态。

### 3.2.6 协同处理（Coprocesses）

协同处理是一个由保留字“coproc”开头的shell命令。一个协同处理是在子shell中异步执行的，并且在执行shell和协同处理进程之间建立一个双向管道。其工作方式就像在命令结尾使用“&”控制操作符一样。

命令格式：

`coproc [NAME] command [redirection]`

这个命令会创建一个名为“NAME”的协同处理。如果没有给出“NAME”，则使用默认名“COPROC”。如果命令是一个简单命令，就不能给出“NAME”。否则，会将其解释为简单命令的第一个单词。

当协同处理执行时，shell会在执行shell上下文中创建一个名为“NAME”的数组变量（参见6.7《数组》）。命令的标准输出会通过管道连接到执行shell中的文件描述符，该描述符分配到“NAME[0]”上。命令的标准输入会通过管道连接到执行shell中的文件描述符，该描述符分配到“NAME[1]”上。文件描述符可以作为Shell命令的参数使用并且重定向使用标准单词扩展。不同于用于执行命令和进程替换创建的文件描述符，其在子shell中是不可用的。

shell产生的用于执行协同处理的进程的ID作为值存储于变量“NAME_PID”中。内建命令“wait”可用于等待协同处理完成。

一旦创建出作为异步命令的协同处理，其“coproc”命令总会反回成功状态。协同处理的返回状态即是命令的退出状态。

### 3.2.7 GNU并行（GNU Parallel）

暂不翻译。